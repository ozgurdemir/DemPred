package dempred.classifier;

import java.lang.reflect.Field;
import java.util.Iterator;
import java.util.List;
import java.util.logging.Logger;

import dempred.datastructure.Datapoint;
import dempred.datastructure.Dataset;
import dempred.resampling.ResamplingErrorInterface;
import dempred.util.Lib;

public class ParameterOptimizer<T extends Datapoint> implements Iterator<ClassifierInterface<T>>, Iterable<ClassifierInterface<T>> {
	private static final Logger logger = Logger.getLogger(ParameterOptimizer.class.getName());
	private int bestIndex = 0;
	private int actualIndex = 0;
	private double smallestError = Double.POSITIVE_INFINITY;
	private ClassifierInterface<T> classifier;
	private Dataset<T> trainset;
	private ResamplingErrorInterface<T> resampler;
	private Field field;
	private Object[] parameterList;
	private double actualError;

	public ParameterOptimizer(ClassifierInterface<T> classifier, Dataset<T> trainset, ResamplingErrorInterface<T> resampler, Field field, Object[] parameterList) {
		super();
		this.classifier = classifier;
		this.trainset = trainset;
		this.resampler = resampler;
		this.field = field;
		this.parameterList = parameterList;
		this.field.setAccessible(true);
	}

	@Override
	public boolean hasNext() {
		return actualIndex < parameterList.length - 1;
	}

	@Override
	public ClassifierInterface<T> next() {
		logger.fine(String.format("Setting %s to %s", field.getName(), parameterList[actualIndex].toString()));
		try {
			field.set(classifier, parameterList[actualIndex]);
			actualError = resampler.error(classifier, trainset);
			logger.fine(String.format("Estimated error: %.4f", actualError));
			if (actualError < smallestError) {
				smallestError = actualError;
				bestIndex = actualIndex;
			}
		} catch (Exception e) {
			logger.fine(Lib.getStackTrace(e));
			return null;
		}
		actualIndex++;
		return classifier;
	}

	public void setBest() throws Exception {
		field.set(classifier, parameterList[bestIndex]);
	}

	@Override
	public void remove() {
		throw new AssertionError("Not allowed");
	}

	@Override
	public Iterator<ClassifierInterface<T>> iterator() {
		return this;
	}

	public Object bestValue() {
		return parameterList[bestIndex];
	}

	public final double getActualError() {
		return actualError;
	}

}
