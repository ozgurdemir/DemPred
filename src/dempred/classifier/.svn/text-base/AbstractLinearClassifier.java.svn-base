package dempred.classifier;

import java.io.Serializable;
import java.util.ArrayList;

import dempred.datastructure.Datapoint;
import dempred.datastructure.Dataset;
import dempred.fmath.FVector;
import dempred.grouper.GrouperInterface;
import dempred.losslunction.LossFunctionInterface;

public abstract class AbstractLinearClassifier<T extends Datapoint> implements ClassifierInterface<T>, Serializable {

	private static final long serialVersionUID = 1584937045062049454L;
	protected transient LossFunctionInterface<T> lossFunction;
	protected transient double w_plus;
	protected transient double lambda2;
	protected transient double lambda1;
	protected transient boolean useDWeights;
	protected transient boolean groupAveraging;
	protected transient FVector epsilon;
	protected FVector weight;
	protected GrouperInterface grouper;

	public final double f(FVector x, FVector w) {
		return x.scalarProduct(w);
	}

	public final FVector f_deriv(FVector x, FVector w) {
		return x.clone();
	}

	public final double L(FVector w, Dataset<T> dataset) {
		double sum_neg = 0.0;
		double sum_pos = 0.0;
		double dweight = 1.0;
		for (T datapoint : dataset.getDatapoints()) {
			if (useDWeights)
				dweight = datapoint.getWeight();
			if (groupAveraging && datapoint.getGroup() == 1)
				sum_pos += dweight * lossFunction.g(f(datapoint.getFeatureVector(), w), datapoint.getValue(), datapoint);
			else
				sum_neg += dweight * lossFunction.g(f(datapoint.getFeatureVector(), w), datapoint.getValue(), datapoint);
		}
		if (groupAveraging) {
			double weight_plus = w_plus / dataset.groupQuantity(1);
			double weight_minus = (1.0 - w_plus) / dataset.groupQuantity(-1);
			return ((weight_minus * sum_neg) + (weight_plus * sum_pos));
		} else
			return (1.0 / dataset.size()) * sum_neg;
	}

	public final double L_mod(FVector w, Dataset<T> dataset) {
		// double obj = 1 - lambda2;
		double obj = 1 - (lambda2 + lambda1);
		FVector wCopy = w.clone();
		wCopy.set(wCopy.size() - 1, 0.0);
		if (epsilon != null) {
			double[] a1 = wCopy.getElements();
			for (int i = 0; i < epsilon.size(); ++i)
				a1[i] *= epsilon.get(i);
		}
		return (obj * L(w, dataset) + lambda2 * wCopy.norm(2));

		// double obj = 1 - (lambda2 + lambda1);
		// FVector wCopy = w.clone();
		// wCopy.set(wCopy.size() - 1, 0.0);
		// if (epsilon != null) {
		// double[] a1 = wCopy.getElements();
		// for (int i = 0; i < epsilon.size(); ++i)
		// a1[i] *= epsilon.get(i);
		// }
		// return (obj * L(w, dataset) + lambda2 * wCopy.norm(2) + lambda1 * wCopy.norm(1));

	}

	public final FVector L_deriv(FVector w, Dataset<T> dataset) {
		FVector sum_neg = new FVector(w.size(), 0.0);
		FVector sum_pos = new FVector(w.size(), 0.0);
		double dweight = 1.0;
		for (T datapoint : dataset.getDatapoints()) {
			if (useDWeights)
				dweight = datapoint.getWeight();
			FVector feature = datapoint.getFeatureVector();
			if (groupAveraging && datapoint.getGroup() == 1)
				sum_pos.addVector(f_deriv(feature, w).mulScalar(dweight * lossFunction.g_deriv(f(feature, w), datapoint.getValue(), datapoint)));
			else
				sum_neg.addVector(f_deriv(feature, w).mulScalar(dweight * lossFunction.g_deriv(f(feature, w), datapoint.getValue(), datapoint)));
		}
		if (groupAveraging) {
			double weight_plus = w_plus / dataset.groupQuantity(1);
			double weight_minus = (1.0 - w_plus) / dataset.groupQuantity(-1);
			return sum_neg.mulScalar(weight_minus).addVector(sum_pos.mulScalar(weight_plus));
		} else
			return sum_neg.mulScalar(1.0 / dataset.size());
	}

	public final FVector L_mod_deriv(FVector w, Dataset<T> dataset) {
		// double obj = 1 - lambda2;
		double obj = 1 - (lambda2 + lambda1);
		FVector wCopy = w.clone();
		wCopy.set(wCopy.size() - 1, 0.0);
		if (epsilon != null) {
			double[] a1 = wCopy.getElements();
			for (int i = 0; i < epsilon.size(); ++i) {
				a1[i] *= epsilon.get(i);
			}
		}
		return (L_deriv(w, dataset).mulScalar(obj).addVector(wCopy.mulScalar(lambda2 * 2)));

		// double obj = 1 - (lambda2 + lambda1);
		// FVector w_copy = w.clone();
		// w_copy.set(w_copy.size() - 1, 0.0);
		// FVector w_copy2 = w.clone();
		// w_copy2.set(w_copy2.size() - 1, 0.0);
		// if (epsilon != null) {
		// double[] a1 = w_copy.getElements();
		// double[] a2 = w_copy2.getElements();
		// for (int i = 0; i < epsilon.size(); ++i) {
		// a1[i] *= epsilon.get(i);
		// a2[i] *= epsilon.get(i);
		// }
		// }
		// return (L_deriv(w, dataset).mulScalar(obj).addVector(w_copy.sign().mulScalar(lambda1)).addVector(w_copy2.mulScalar(lambda2 * 2)));
	}

	public final void predict(Dataset<T> dataset) throws IllegalArgumentException {
		dataset.extend(1.0);
		for (Datapoint datapoint : dataset.getDatapoints()) {
			datapoint.setPredictedValue(f(datapoint.getFeatureVector(), weight));
			if (grouper != null)
				datapoint.setPredictedGroup(grouper.getGroup(datapoint.getPredictedValue()));
		}
		dataset.reduce();
	}

	public final double predict(Datapoint datapoint) throws IllegalArgumentException {
		datapoint.getFeatureVector().extendByOne(1.0);
		double value = f(datapoint.getFeatureVector(), weight);
		datapoint.setPredictedValue(value);
		if (grouper != null)
			datapoint.setPredictedGroup(grouper.getGroup(value));
		datapoint.getFeatureVector().reduceByOne();
		return value;
	}

	// achtung funktioniert nicht mit kernels!
	// wenn effectVector
	// positiv = feature verkleinert den Fehler, also wichtiges Feature
	// null = feature hat keine Auswirkung, also unwichtig
	// negativ = feature vergroessert den Fehler, also besser ohne
	public final FVector effectObjFunc(Dataset<T> dataset) {
		dataset.extend(1.0);
		double sum_neg = 0.0;
		double sum_pos = 0.0;
		double weight_plus = 1.0 / dataset.size();
		double weight_minus = 1.0 / dataset.size();
		if (groupAveraging) {
			weight_plus = w_plus / dataset.groupQuantity(1);
			weight_minus = (1.0 - w_plus) / dataset.groupQuantity(-1);
		}
		ArrayList<Double> tempVec = new ArrayList<Double>(dataset.size() - 1);
		FVector effectVec = new FVector(dataset.numFeatures() - 1);
		for (T datapoint : dataset.getDatapoints()) {
			if (groupAveraging && datapoint.getGroup() == 1)
				sum_pos += lossFunction.g(f(datapoint.getFeatureVector(), weight), datapoint.getValue(), datapoint);
			else
				sum_neg += lossFunction.g(f(datapoint.getFeatureVector(), weight), datapoint.getValue(), datapoint);
			tempVec.add(f(datapoint.getFeatureVector(), weight));
		}
		double with_weight = (weight_minus * sum_neg) + (weight_plus * sum_pos);
		for (int j = 0; j < effectVec.size(); ++j) {
			sum_pos = 0.0;
			sum_neg = 0.0;
			int i = 0;
			for (T datapoint : dataset.getDatapoints()) {
				if (groupAveraging && datapoint.getGroup() == 1)
					sum_pos += lossFunction.g(tempVec.get(i) - (datapoint.getFeatureAt(j) * weight.get(j)), datapoint.getValue(), datapoint);
				else
					sum_neg += lossFunction.g(tempVec.get(i) - (datapoint.getFeatureAt(j) * weight.get(j)), datapoint.getValue(), datapoint);
				++i;
			}
			double without_weight = (weight_minus * sum_neg) + (weight_plus * sum_pos);
			effectVec.set(j, (without_weight - with_weight));
		}
		dataset.reduce();
		return effectVec;
	}

	public final FVector effectObjRetrain(Dataset<T> dataset) throws Exception {
		FVector rank = new FVector(dataset.numFeatures());
		dataset.extend(1.0);
		double with_weight = L(weight, dataset);
		dataset.reduce();
		for (int i = 0; i < rank.size(); ++i) {
			Dataset<T> reducedDataset = dataset.clone();
			int[] deletedFeatures = { i };
			reducedDataset.deleteFeatures(deletedFeatures);
			this.learn(reducedDataset);
			reducedDataset.extend(1.0);
			double without_weight = L(weight, reducedDataset);
			reducedDataset.reduce();
			rank.set(i, without_weight - with_weight);
		}
		return rank;
	}

	public final FVector[] effectObjRetrain(Dataset<T> trainset, Dataset<T> testset) throws Exception {
		FVector rankTrain = new FVector(trainset.numFeatures());
		FVector rankTest = new FVector(trainset.numFeatures());
		trainset.extend(1.0);
		testset.extend(1.0);
		double with_weight_train = L(weight, trainset);
		double with_weight_test = L(weight, testset);
		trainset.reduce();
		testset.reduce();
		for (int i = 0; i < rankTrain.size(); ++i) {
			Dataset<T> reducedTrainset = trainset.clone();
			Dataset<T> reducedTestset = testset.clone();
			int[] deletedFeatures = { i };
			reducedTrainset.deleteFeatures(deletedFeatures);
			reducedTestset.deleteFeatures(deletedFeatures);
			this.learn(reducedTrainset);
			reducedTrainset.extend(1.0);
			reducedTestset.extend(1.0);
			double without_weight_train = L(weight, reducedTrainset);
			double without_weight_test = L(weight, reducedTestset);
			reducedTrainset.reduce();
			reducedTestset.reduce();
			rankTrain.set(i, without_weight_train - with_weight_train);
			rankTest.set(i, without_weight_test - with_weight_test);
		}
		FVector[] resultRank = { rankTrain, rankTest };
		return resultRank;
	}

	@Override
	@SuppressWarnings("unchecked")
	public ClassifierInterface<T> clone() {
		try {
			return (AbstractLinearClassifier<T>) super.clone();
		} catch (CloneNotSupportedException e) {
			e.printStackTrace();
			return null;
		}
	}

	// ********************************************
	// getters and setters
	// ********************************************

	public final double getW_plus() {
		return w_plus;
	}

	public final void setW_plus(double w_plus) {
		this.w_plus = w_plus;
	}

	public final double getLambda2() {
		return lambda2;
	}

	public final void setLambda2(double lambda) {
		this.lambda2 = lambda;
	}

	public final double getLambda1() {
		return lambda1;
	}

	public final void setLambda1(double lambda1) {
		this.lambda1 = lambda1;
	}

	public final FVector getWeight() {
		return weight;
	}

	public final void setWeight(FVector weight) {
		this.weight = weight;
	}

	public final String getLossFunctionName() {
		return lossFunction.getName();
	}

	public final boolean isUseDWeights() {
		return useDWeights;
	}

	public final void setUseDWeights(boolean useDWeights) {
		this.useDWeights = useDWeights;
	}

	public final LossFunctionInterface<T> getLossFunction() {
		return lossFunction;
	}

	public final void setLossFunction(LossFunctionInterface<T> lossFunction) {
		this.lossFunction = lossFunction;
	}

	public final FVector getEpsilon() {
		return epsilon;
	}

	public final void setEpsilon(FVector epsilon) {
		this.epsilon = epsilon;
	}

	public final GrouperInterface getGrouper() {
		return grouper;
	}

	public final void setGrouper(GrouperInterface grouper) {
		this.grouper = grouper;
	}

	public final boolean isGroupAveraging() {
		return groupAveraging;
	}

	public final void setGroupAveraging(boolean groupAveraging) {
		this.groupAveraging = groupAveraging;
	}
}
