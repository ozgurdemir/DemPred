package dempred.datastructure;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import dempred.fmath.FVector;
import dempred.fmath.FVectorMetric;
import dempred.losslunction.LossFunctionInterface;
import dempred.transformer.DatasetTransformer;
import dempred.transformer.NoTransformation;
import dempred.transformer.TransformationFunctionInterface;




public class DatasetResult {

	public static <T extends Datapoint> double lossFunction(Dataset<T> dataset, LossFunctionInterface<T> lossFunction) {
		double result = 0.0;
		for (T datapoint : dataset.getDatapoints())
			result += lossFunction.g(datapoint.getValue(), datapoint.getPredictedValue(), datapoint);
		return result;
	}

	public static double mcc(Dataset<?> dataset) {
		int numPositives = dataset.groupQuantity(1);
		int numNegatives = dataset.groupQuantity(-1);
		int correctPositives = dataset.numCorrectPredictions(1);
		int correctNegatives = dataset.numCorrectPredictions(-1);
		return mcc(correctPositives, correctNegatives, numNegatives - correctNegatives, numPositives - correctPositives);
	}

	public static double mcc(double truepos, double trueneg, double falsepos, double falseneg) {
		return ((truepos * trueneg - falsepos * falseneg) / Math.sqrt(((truepos + falsepos) * (truepos + falseneg) * (trueneg + falsepos) * (trueneg + falseneg))));
	}

	public static double accuracy(Dataset<?> dataset) {
		int numNegatives = dataset.groupQuantity(-1);
		int correctNegatives = dataset.numCorrectPredictions(-1);
		double truepos = dataset.numCorrectPredictions(1);
		double falsepos = numNegatives - correctNegatives;
		return truepos / (truepos + falsepos);
	}

	// r = linear correlation coeficient
	// r2 = coefficient of determination, there are different definitions for r2.
	// Only in case of a linear regression all definitions are equal and r2=pcc^2
	// q2 = same as r2 but via crossvalidation. r2 is normally on recall
	public static double r2q2(Dataset<?> dataset) {
		double mean = computeValueMean(dataset);
		double sum1 = 0.0;
		double sum2 = 0.0;
		for (Datapoint datapoint : dataset.getDatapoints()) {
			sum1 += Math.pow(datapoint.getValue() - datapoint.getPredictedValue(), 2);
			sum2 += Math.pow(datapoint.getValue() - mean, 2);
		}
		return 1 - (sum1 / sum2);
	}

	public static double computeValueMean(Dataset<?> dataset) {
		double mean = 0.0;
		for (Datapoint datapoint : dataset.getDatapoints())
			mean += datapoint.getValue();
		mean /= dataset.size();
		return mean;
	}

	// also called r or linear correlation coefficient
	public static double pcc(Dataset<?> dataset) {
		FVector measuredValues = new FVector(dataset.size());
		FVector predictedValues = new FVector(dataset.size());
		for (int i = 0; i < dataset.size(); ++i) {
			Datapoint datapoint = dataset.getDatapoint(i);
			measuredValues.set(i, datapoint.getValue());
			predictedValues.set(i, datapoint.getPredictedValue());
		}
		return FVectorMetric.pcc(measuredValues, predictedValues);
	}

	public static double rmsd(Dataset<?> dataset) {
		double result = 0.0;
		for (Datapoint datapoint : dataset.getDatapoints())
			result += Math.pow(datapoint.getValue() - datapoint.getPredictedValue(), 2.0);
		return Math.sqrt(result / dataset.size());
	}

	// also called geometric mean fold error
	// geometrische mittel der fehler die gemacht wurden
	// geometrische mittel: n-te wurzel der produkte von n nummern (fehlern)
	public static double averageFoldError(Dataset<?> dataset) {
		return averageFoldError(dataset, new NoTransformation());
	}

	public static double averageFoldError(Dataset<?> dataset, TransformationFunctionInterface transformationFunction) {
		double foldError = 0.0;
		for (Datapoint datapoint : dataset.getDatapoints())
			foldError += Math.abs(Math.log10(transformationFunction.transform(datapoint.getPredictedValue()) / transformationFunction.transform(datapoint.getValue())));
		foldError /= dataset.size();
		foldError = Math.pow(10, foldError);
		return foldError;
	}

	public static double foldError(Dataset<?> dataset) {
		double foldError = 0.0;
		for (Datapoint datapoint : dataset.getDatapoints()) {
			if (datapoint.getValue() > datapoint.getPredictedValue())
				foldError += datapoint.getValue() / datapoint.getPredictedValue();
			else
				foldError += datapoint.getPredictedValue() / datapoint.getValue();
		}
		return foldError;
	}
	
	public static double auc(Dataset<?> dataset) {
		int p = dataset.groupQuantity(1);
		int n = dataset.groupQuantity(-1);
		int fp = 0;
		int tp = 0;
		int fpPrev = 0;
		int tpPrev = 0;
		double a = 0.0;
		double fprev = Double.NEGATIVE_INFINITY;
		List<Datapoint> tempSet = new ArrayList<Datapoint>(dataset.getDatapoints());
		Collections.sort(tempSet, new Datapoint.ClassificationValueComparatorDesc());
		for (Datapoint datapoint : tempSet) {
			if (datapoint.getPredictedValue() != fprev) {
				a += trapezoid_area(fp, fpPrev, tp, tpPrev);
				fprev = datapoint.getPredictedValue();
				fpPrev = fp;
				tpPrev = tp;
			}
			if (datapoint.getGroup() != null && datapoint.getGroup() == 1)
				tp++;
			else
				fp++;
		}
		a += trapezoid_area(fp, fpPrev, tp, tpPrev);
		a /= p * n;
		return a;
	}

	private static double trapezoid_area(double x1, double x2, double y1, double y2) {
		double base = Math.abs(x1 - x2);
		double height = (y1 + y2) / 2.0;
		return base * height;
	}

	public static String toStringClassification(Dataset<?> dataset) {
		int numPositives = dataset.groupQuantity(1);
		int numNegatives = dataset.groupQuantity(-1);
		int correctPositives = dataset.numCorrectPredictions(1);
		int correctNegatives = dataset.numCorrectPredictions(-1);
		int total = numPositives + numNegatives;
		int TotalRight = correctPositives + correctNegatives;
		double fractPosRight = ((double) 100.0 * correctPositives / numPositives);
		double fractNegRight = ((double) 100.0 * correctNegatives / numNegatives);
		double mcc = mcc(correctPositives, correctNegatives, numNegatives - correctNegatives, numPositives - correctPositives);
		double auc = auc(dataset);
		return String.format("PosRight: %d of %d(%.2f%%) | NegRight %d of %d(%.2f%%) | total %d of %d(%.2f%%) | MCC: %.4f | AUC:%.4f", correctPositives, numPositives, fractPosRight, correctNegatives, numNegatives, fractNegRight, TotalRight, total, ((fractPosRight + fractNegRight) / 2), mcc, auc);
	}
	
	public static String toStringRegression(Dataset<?> dataset) {
		return String.format("RMSD:%.4f | Q2:%.4f | GMFE:%.4f", rmsd(dataset), r2q2(dataset), averageFoldError(dataset));
	}

	public static String toCVS(Dataset<?> dataset) {
		int numPositives = dataset.groupQuantity(1);
		int numNegatives = dataset.groupQuantity(-1);
		int correctPositives = dataset.numCorrectPredictions(1);
		int correctNegatives = dataset.numCorrectPredictions(-1);
		int total = numPositives + numNegatives;
		int TotalRight = correctPositives + correctNegatives;
		double fractPosRight = ((double) 100.0 * correctPositives / numPositives);
		double fractNegRight = ((double) 100.0 * correctNegatives / numNegatives);
		double mcc = mcc(correctPositives, correctNegatives, numNegatives - correctNegatives, numPositives - correctPositives);
		return String.format("%d,%d,%.2f,%d,%d,%.2f,%d,%d,%.2f,%.4f", correctPositives, numPositives, fractPosRight, correctNegatives, numNegatives, fractNegRight, TotalRight, total, ((fractPosRight + fractNegRight) / 2), mcc);
	}

	// **************************************************************

}
